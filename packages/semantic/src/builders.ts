// This file is generated by scripts/codegen.ts
// Do not edit this file directly

/* eslint-disable no-shadow-restricted-names */

import type { Node, NodeTypes, NumericRelation } from './types';
import { NodeType } from './enums';
import { SourceLocation } from './types';
import { getId } from '@math-blocks/core';

const builders = {
  identifier: (name: string, subscript?: Node, loc?: SourceLocation): NodeTypes['Identifier'] => ({
    type: 'Identifier',
    id: getId(),
    name,
    subscript,
    loc,
  }),
  function: (func: Node, args: readonly Node[], loc?: SourceLocation): NodeTypes['Function'] => ({
    type: 'Function',
    id: getId(),
    func,
    args,
    loc,
  }),
  plusminus: (args: TwoOrMore<Node>, loc?: SourceLocation): NodeTypes['PlusMinus'] => ({
    type: 'PlusMinus',
    id: getId(),
    args,
    loc,
  }),
  minusplus: (args: TwoOrMore<Node>, loc?: SourceLocation): NodeTypes['MinusPlus'] => ({
    type: 'MinusPlus',
    id: getId(),
    args,
    loc,
  }),
  unaryplusminus: (arg: Node, loc?: SourceLocation): NodeTypes['UnaryPlusMinus'] => ({
    type: 'UnaryPlusMinus',
    id: getId(),
    arg,
    loc,
  }),
  unaryminusplus: (arg: Node, loc?: SourceLocation): NodeTypes['UnaryMinusPlus'] => ({
    type: 'UnaryMinusPlus',
    id: getId(),
    arg,
    loc,
  }),
  div: (arg0: Node, arg1: Node, loc?: SourceLocation): NodeTypes['Div'] => ({
    type: 'Div',
    id: getId(),
    args: [arg0, arg1],
    loc,
  }),
  mod: (arg0: Node, arg1: Node, loc?: SourceLocation): NodeTypes['Mod'] => ({
    type: 'Modulo',
    id: getId(),
    args: [arg0, arg1],
    loc,
  }),
  pow: (base: Node, exp: Node, loc?: SourceLocation): NodeTypes['Pow'] => ({
    type: 'Power',
    id: getId(),
    base,
    exp,
    loc,
  }),
  root: (radicand: Node, index: Node, sqrt = false, loc?: SourceLocation): NodeTypes['Root'] => ({
    type: 'Root',
    id: getId(),
    radicand,
    index,
    sqrt,
    loc,
  }),
  abs: (arg: Node, loc?: SourceLocation): NodeTypes['Abs'] => ({
    type: 'AbsoluteValue',
    id: getId(),
    arg,
    loc,
  }),
  neg: (arg: Node, subtraction = false, loc?: SourceLocation): NodeTypes['Neg'] => ({
    type: 'Neg',
    id: getId(),
    arg,
    subtraction,
    loc,
  }),
  sin: (arg: Node, loc?: SourceLocation): NodeTypes['Sin'] => ({
    type: 'Sin',
    id: getId(),
    arg,
    loc,
  }),
  cos: (arg: Node, loc?: SourceLocation): NodeTypes['Cos'] => ({
    type: 'Cos',
    id: getId(),
    arg,
    loc,
  }),
  tan: (arg: Node, loc?: SourceLocation): NodeTypes['Tan'] => ({
    type: 'Tan',
    id: getId(),
    arg,
    loc,
  }),
  cot: (arg: Node, loc?: SourceLocation): NodeTypes['Cot'] => ({
    type: 'Cot',
    id: getId(),
    arg,
    loc,
  }),
  sec: (arg: Node, loc?: SourceLocation): NodeTypes['Sec'] => ({
    type: 'Sec',
    id: getId(),
    arg,
    loc,
  }),
  csc: (arg: Node, loc?: SourceLocation): NodeTypes['Csc'] => ({
    type: 'Csc',
    id: getId(),
    arg,
    loc,
  }),
  arcsin: (arg: Node, loc?: SourceLocation): NodeTypes['ArcSin'] => ({
    type: 'ArcSin',
    id: getId(),
    arg,
    loc,
  }),
  arccos: (arg: Node, loc?: SourceLocation): NodeTypes['ArcCos'] => ({
    type: 'ArcCos',
    id: getId(),
    arg,
    loc,
  }),
  arctan: (arg: Node, loc?: SourceLocation): NodeTypes['ArcTan'] => ({
    type: 'ArcTan',
    id: getId(),
    arg,
    loc,
  }),
  arccot: (arg: Node, loc?: SourceLocation): NodeTypes['ArcCot'] => ({
    type: 'ArcCot',
    id: getId(),
    arg,
    loc,
  }),
  arcsec: (arg: Node, loc?: SourceLocation): NodeTypes['ArcSec'] => ({
    type: 'ArcSec',
    id: getId(),
    arg,
    loc,
  }),
  arccsc: (arg: Node, loc?: SourceLocation): NodeTypes['ArcCsc'] => ({
    type: 'ArcCsc',
    id: getId(),
    arg,
    loc,
  }),
  log: (base: Node, arg: Node, loc?: SourceLocation): NodeTypes['Log'] => ({
    type: 'Log',
    id: getId(),
    base,
    arg,
    loc,
  }),
  ln: (arg: Node, loc?: SourceLocation): NodeTypes['Ln'] => ({
    type: 'Ln',
    id: getId(),
    arg,
    loc,
  }),
  exp: (arg: Node, loc?: SourceLocation): NodeTypes['Exp'] => ({
    type: 'Exp',
    id: getId(),
    arg,
    loc,
  }),
  gt: (args: TwoOrMore<Node>, loc?: SourceLocation): NodeTypes['Gt'] => ({
    type: 'GreaterThan',
    id: getId(),
    args,
    loc,
  }),
  gte: (args: TwoOrMore<Node>, loc?: SourceLocation): NodeTypes['Gte'] => ({
    type: 'GreaterThanOrEquals',
    id: getId(),
    args,
    loc,
  }),
  lt: (args: TwoOrMore<Node>, loc?: SourceLocation): NodeTypes['Lt'] => ({
    type: 'LessThan',
    id: getId(),
    args,
    loc,
  }),
  lte: (args: TwoOrMore<Node>, loc?: SourceLocation): NodeTypes['Lte'] => ({
    type: 'LessThanOrEquals',
    id: getId(),
    args,
    loc,
  }),
  infinity: (loc?: SourceLocation): NodeTypes['Infinity'] => ({
    type: 'Infinity',
    id: getId(),
    loc,
  }),
  pi: (loc?: SourceLocation): NodeTypes['Pi'] => ({
    type: 'Pi',
    id: getId(),
    loc,
  }),
  e: (loc?: SourceLocation): NodeTypes['E'] => ({
    type: 'E',
    id: getId(),
    loc,
  }),
  ellipsis: (loc?: SourceLocation): NodeTypes['Ellipsis'] => ({
    type: 'Ellipsis',
    id: getId(),
    loc,
  }),
  and: (args: TwoOrMore<Node>, loc?: SourceLocation): NodeTypes['And'] => ({
    type: 'LogicalAnd',
    id: getId(),
    args,
    loc,
  }),
  or: (args: TwoOrMore<Node>, loc?: SourceLocation): NodeTypes['Or'] => ({
    type: 'LogicalOr',
    id: getId(),
    args,
    loc,
  }),
  xor: (args: TwoOrMore<Node>, loc?: SourceLocation): NodeTypes['Xor'] => ({
    type: 'ExclusiveOr',
    id: getId(),
    args,
    loc,
  }),
  not: (arg: Node, loc?: SourceLocation): NodeTypes['Not'] => ({
    type: 'LogicalNot',
    id: getId(),
    arg,
    loc,
  }),
  implies: (arg0: Node, arg1: Node, loc?: SourceLocation): NodeTypes['Implies'] => ({
    type: 'Conditional',
    id: getId(),
    args: [arg0, arg1],
    loc,
  }),
  equivalent: (arg0: Node, arg1: Node, loc?: SourceLocation): NodeTypes['Equivalent'] => ({
    type: 'Biconditional',
    id: getId(),
    args: [arg0, arg1],
    loc,
  }),
  true: (loc?: SourceLocation): NodeTypes['True'] => ({
    type: 'True',
    id: getId(),
    loc,
  }),
  false: (loc?: SourceLocation): NodeTypes['False'] => ({
    type: 'False',
    id: getId(),
    loc,
  }),
  set: (args: TwoOrMore<Node>, loc?: SourceLocation): NodeTypes['Set'] => ({
    type: 'Set',
    id: getId(),
    args,
    loc,
  }),
  union: (args: TwoOrMore<Node>, loc?: SourceLocation): NodeTypes['Union'] => ({
    type: 'Union',
    id: getId(),
    args,
    loc,
  }),
  intersection: (args: TwoOrMore<Node>, loc?: SourceLocation): NodeTypes['Intersection'] => ({
    type: 'SetIntersection',
    id: getId(),
    args,
    loc,
  }),
  cartesianproduct: (args: TwoOrMore<Node>, loc?: SourceLocation): NodeTypes['CartesianProduct'] => ({
    type: 'CartesianProduct',
    id: getId(),
    args,
    loc,
  }),
  setdiff: (arg0: Node, arg1: Node, loc?: SourceLocation): NodeTypes['SetDiff'] => ({
    type: 'SetDifference',
    id: getId(),
    args: [arg0, arg1],
    loc,
  }),
  subset: (args: TwoOrMore<Node>, loc?: SourceLocation): NodeTypes['Subset'] => ({
    type: 'Subset',
    id: getId(),
    args,
    loc,
  }),
  propersubset: (args: TwoOrMore<Node>, loc?: SourceLocation): NodeTypes['ProperSubset'] => ({
    type: 'ProperSubset',
    id: getId(),
    args,
    loc,
  }),
  superset: (args: TwoOrMore<Node>, loc?: SourceLocation): NodeTypes['Superset'] => ({
    type: 'Superset',
    id: getId(),
    args,
    loc,
  }),
  propersuperset: (args: TwoOrMore<Node>, loc?: SourceLocation): NodeTypes['ProperSuperset'] => ({
    type: 'ProperSuperset',
    id: getId(),
    args,
    loc,
  }),
  notsubset: (arg0: Node, arg1: Node, loc?: SourceLocation): NodeTypes['NotSubset'] => ({
    type: 'NotSubset',
    id: getId(),
    args: [arg0, arg1],
    loc,
  }),
  notpropersubset: (arg0: Node, arg1: Node, loc?: SourceLocation): NodeTypes['NotProperSubset'] => ({
    type: 'NotProperSubset',
    id: getId(),
    args: [arg0, arg1],
    loc,
  }),
  notsuperset: (arg0: Node, arg1: Node, loc?: SourceLocation): NodeTypes['NotSuperset'] => ({
    type: 'NotSuperset',
    id: getId(),
    args: [arg0, arg1],
    loc,
  }),
  notpropersuperset: (arg0: Node, arg1: Node, loc?: SourceLocation): NodeTypes['NotProperSuperset'] => ({
    type: 'NotProperSuperset',
    id: getId(),
    args: [arg0, arg1],
    loc,
  }),
  in: (element: Node, set: Node, loc?: SourceLocation): NodeTypes['In'] => ({
    type: 'ElementOf',
    id: getId(),
    element,
    set,
    loc,
  }),
  notin: (element: Node, set: Node, loc?: SourceLocation): NodeTypes['NotIn'] => ({
    type: 'NotElementOf',
    id: getId(),
    element,
    set,
    loc,
  }),
  emptyset: (loc?: SourceLocation): NodeTypes['EmptySet'] => ({
    type: 'EmptySet',
    id: getId(),
    loc,
  }),
  naturals: (loc?: SourceLocation): NodeTypes['Naturals'] => ({
    type: 'Naturals',
    id: getId(),
    loc,
  }),
  integers: (loc?: SourceLocation): NodeTypes['Integers'] => ({
    type: 'Integers',
    id: getId(),
    loc,
  }),
  rationals: (loc?: SourceLocation): NodeTypes['Rationals'] => ({
    type: 'Rationals',
    id: getId(),
    loc,
  }),
  reals: (loc?: SourceLocation): NodeTypes['Reals'] => ({
    type: 'Reals',
    id: getId(),
    loc,
  }),
  complexes: (loc?: SourceLocation): NodeTypes['Complexes'] => ({
    type: 'Complexes',
    id: getId(),
    loc,
  }),
  matrix: (args: TwoOrMore<Node>, rows: number, cols: number, loc?: SourceLocation): NodeTypes['Matrix'] => ({
    type: 'Matrix',
    id: getId(),
    args,
    rows,
    cols,
    loc,
  }),
  vector: (args: TwoOrMore<Node>, dim: number, loc?: SourceLocation): NodeTypes['Vector'] => ({
    type: 'Vector',
    id: getId(),
    args,
    dim,
    loc,
  }),
  determinant: (arg: Node, loc?: SourceLocation): NodeTypes['Determinant'] => ({
    type: 'Determinant',
    id: getId(),
    arg,
    loc,
  }),
  transpose: (arg: Node, loc?: SourceLocation): NodeTypes['Transpose'] => ({
    type: 'Transpose',
    id: getId(),
    arg,
    loc,
  }),
  vectorproduct: (arg0: Node, arg1: Node, loc?: SourceLocation): NodeTypes['VectorProduct'] => ({
    type: 'VectorProduct',
    id: getId(),
    args: [arg0, arg1],
    loc,
  }),
  scalarproduct: (arg0: Node, arg1: Node, loc?: SourceLocation): NodeTypes['ScalarProduct'] => ({
    type: 'ScalarProduct',
    id: getId(),
    args: [arg0, arg1],
    loc,
  }),
  limit: (arg: Node, bvar: NodeTypes['Identifier'], to: NodeTypes['Number'] | NodeTypes['Neg'], approach: 'left' | 'right' | 'both', loc?: SourceLocation): NodeTypes['Limit'] => ({
    type: 'Limit',
    id: getId(),
    arg,
    bvar,
    to,
    approach,
    loc,
  }),
  integral: (arg: Node, bvar: NodeTypes['Identifier'], loc?: SourceLocation): NodeTypes['Integral'] => ({
    type: 'Integral',
    id: getId(),
    arg,
    bvar,
    loc,
  }),
  defint: (arg: Node, bvar: NodeTypes['Identifier'], lower: Node, upper: Node, loc?: SourceLocation): NodeTypes['DefInt'] => ({
    type: 'DefiniteIntegral',
    id: getId(),
    arg,
    bvar,
    lower,
    upper,
    loc,
  }),
  diff: (arg: Node, bvar: NodeTypes['Identifier'], degree: Node, loc?: SourceLocation): NodeTypes['Diff'] => ({
    type: 'Derivative',
    id: getId(),
    arg,
    bvar,
    degree,
    loc,
  }),
  partialdiff: (arg: Node, bvars: readonly NodeTypes['Identifier'][], degrees: readonly Node[], loc?: SourceLocation): NodeTypes['PartialDiff'] => ({
    type: 'PartialDerivative',
    id: getId(),
    arg,
    bvars,
    degrees,
    loc,
  }),
  sequence: (args: TwoOrMore<Node>, loc?: SourceLocation): NodeTypes['Sequence'] => ({
    type: 'Sequence',
    id: getId(),
    args,
    loc,
  }),
  sum: (arg: Node, bvar: NodeTypes['Identifier'], lower: Node, upper: Node, loc?: SourceLocation): NodeTypes['Sum'] => ({
    type: 'Sum',
    id: getId(),
    arg,
    bvar,
    lower,
    upper,
    loc,
  }),
  product: (arg: Node, bvar: NodeTypes['Identifier'], lower: Node, upper: Node, loc?: SourceLocation): NodeTypes['Product'] => ({
    type: 'Product',
    id: getId(),
    arg,
    bvar,
    lower,
    upper,
    loc,
  }),
  eq: (args: TwoOrMore<Node>, loc?: SourceLocation): NodeTypes['Eq'] => ({
    type: 'Equals',
    id: getId(),
    args,
    loc,
  }),
  neq: (args: TwoOrMore<Node>, loc?: SourceLocation): NodeTypes['Neq'] => ({
    type: 'NotEquals',
    id: getId(),
    args,
    loc,
  }),
  parens: (arg: Node, loc?: SourceLocation): NodeTypes['Parens'] => ({
    type: 'Parens',
    id: getId(),
    arg,
    loc,
  }),

  add: (
    terms: readonly Node[],
    loc?: SourceLocation,
  ): Node => {
    switch (terms.length) {
      case 0:
        return builders.number('0'); // , loc);
      case 1:
        return terms[0]; // TODO: figure out if we should give this node a location
      default:
        return {
          type: NodeType.Add,
          id: getId(),
          args: terms as TwoOrMore<Node>,
          loc,
        };
    }
  },

  mul: (
    factors: readonly Node[],
    implicit = false,
    loc?: SourceLocation,
  ): Node => {
    switch (factors.length) {
      case 0:
        return builders.number('1'); // , loc);
      case 1:
        return factors[0]; // TODO: figure out if we should give this node a location
      default:
        return {
          type: NodeType.Mul,
          id: getId(),
          implicit,
          args: factors as TwoOrMore<Node>,
          loc,
        };
    }
  },

  numRel: (
    args: TwoOrMore<Node>,
    type: NumericRelation['type'],
    loc?: SourceLocation,
  ): NumericRelation => ({
    type,
    id: getId(),
    args,
  }),

  number: (
    value: string,
    loc?: SourceLocation,
  ): NodeTypes['Number'] | NodeTypes['Neg'] => {
    if (value.startsWith('-')) {
      // TODO: handle location data correctly
      return builders.neg(builders.number(value.slice(1)));
    }
    return {
      type: NodeType.Number,
      id: getId(),
      value: value.replace(/-/g, '−'),
      loc,
    };
  },

  sqrt: (
    radicand: Node,
    loc?: SourceLocation,
  ): NodeTypes['Root'] => builders.root(radicand, builders.number('2'), true, loc),
};

export default builders;
