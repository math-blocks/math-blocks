#!/usr/bin/env -S node -r @swc-node/register
import fs from 'fs';
import path from 'path';
import { definitions } from './node-defs';

/* istanbul ignore next */
const generateNodeTypes = () => {
  // eslint-disable-next-line functional/prefer-readonly-type
  const lines: string[] = [];

  lines.push('// This file is generated by scripts/codegen.ts');
  lines.push('// Do not edit this file directly');
  lines.push('');
  lines.push('export type SourceLocation = {');
  lines.push('  readonly path: readonly number[];');
  lines.push('  readonly start: number;');
  lines.push('  readonly end: number;');
  lines.push('};');
  lines.push('');
  lines.push('export type Style = {');
  lines.push('  readonly color?: string;');
  lines.push('};');
  lines.push('');
  lines.push('export type Common<T extends string> = {');
  lines.push('  readonly type: T;');
  lines.push('  readonly id: number;');
  lines.push('  readonly loc?: SourceLocation;');
  lines.push(
    '  source?: string; // eslint-disable-line functional/prefer-readonly-type',
  );
  lines.push(
    '  style?: Style; // eslint-disable-line functional/prefer-readonly-type',
  );
  lines.push('};');
  lines.push('');

  lines.push('export interface NodeTypes {');
  for (const [name, node] of Object.entries(definitions)) {
    // eslint-disable-next-line functional/prefer-readonly-type
    const properties: string[] = [];

    if (node.kind === 'operation' || node.kind === 'relation') {
      if (node.argNames) {
        for (const argName of node.argNames) {
          properties.push(`readonly ${argName}: Node`);
        }
      } else {
        switch (node.arity) {
          case 'unary':
            properties.push(`readonly arg: Node`); // TODO: change to `args: [Node];`
            break;
          case 'binary':
            properties.push(`readonly args: readonly [Node, Node]`);
            break;
          case 'nary':
            properties.push(`readonly args: TwoOrMore<Node>`);
            break;
        }
      }
    } else if (node.kind === 'constructor') {
      switch (node.arity) {
        case 'unary':
          properties.push(`readonly arg: Node`); // TODO: change to `args: [Node];`
          break;
        case 'binary':
          properties.push(`readonly args: readonly [Node, Node]`);
          break;
        case 'nary':
          if (name === 'Matrix' || name === 'Vector') {
            properties.push(`readonly args: readonly Node[]`);
          } else {
            properties.push(`readonly args: TwoOrMore<Node>`);
          }
          break;
      }
    } else if (node.kind === 'number') {
      properties.push(`readonly value: string`);
    } else if (node.kind === 'identifier') {
      properties.push(`readonly name: string`);
      properties.push(`readonly subscript?: Node`);
    } else if (node.kind === 'constant') {
      // no properties
    } else if (node.kind === 'function') {
      properties.push(`readonly func: Node`);
      properties.push(`readonly args: readonly Node[]`);
    }

    if ('options' in node && node.options) {
      for (const [key, type] of Object.entries(node.options)) {
        properties.push(`readonly ${key}: ${type}`);
      }
    }

    if (properties.length === 1) {
      lines.push(
        `  readonly ${name}: Common<'${node.name}'> & {${properties.join(
          ', ',
        )}}`,
      );
    } else if (properties.length > 1) {
      lines.push(`  readonly ${name}: Common<'${node.name}'> & {`);
      for (const prop of properties) {
        lines.push(`    ${prop},`);
      }
      lines.push('  },');
    } else {
      lines.push(`  readonly ${name}: Common<'${node.name}'>,`);
    }
  }
  lines.push('}');
  lines.push('');
  lines.push('export type Node = NodeTypes[keyof NodeTypes];');
  lines.push('');
  for (const name of Object.keys(definitions)) {
    lines.push(`export type ${name} = NodeTypes['${name}'];`);
  }

  lines.push(`export type NumericRelation =
  | NodeTypes['Eq']
  | NodeTypes['Neq']
  | NodeTypes['Lt']
  | NodeTypes['Lte']
  | NodeTypes['Gt']
  | NodeTypes['Gte'];`);
  lines.push("export type NumRelType = NumericRelation['type'];");

  fs.writeFileSync(path.join(__dirname, 'types.ts'), lines.join('\n'));
};

/* istanbul ignore next */
// const generateNodeUtils = () => {
//   // eslint-disable-next-line functional/prefer-readonly-type
//   const lines: string[] = [];

//   lines.push('// This file is generated by scripts/codegen.ts');
//   lines.push('// Do not edit this file directly');
//   lines.push('');
//   lines.push("import { definitions } from './node-defs';");
//   lines.push("import type { Node, NodeTypes } from './node-types';");
//   lines.push('');

//   for (const [name, node] of Object.entries(definitions)) {
//     // TODO: special case nodes that have boolean flags
//     lines.push(
//       `export const is${name} = (node: Node): node is NodeTypes['${name}'] => node.type === '${node.name}';`,
//     );
//   }

//   lines.push('');
//   lines.push(
//     'export const isRelational = (node: Node): node is NodeTypes[keyof NodeTypes] => definitions[node.type]?.kind === "relation";',
//   );
//   lines.push(
//     'export const isConstant = (node: Node): node is NodeTypes[keyof NodeTypes] => definitions[node.type]?.kind === "constant";',
//   );
//   lines.push('');

//   fs.writeFileSync(path.join(__dirname, 'node-util.ts'), lines.join('\n'));
// };

/* istanbul ignore next */
const generateNodeBuilders = () => {
  const lines: string[] = [];

  lines.push('// This file is generated by scripts/codegen.ts');
  lines.push('// Do not edit this file directly');
  lines.push('');
  lines.push('/* eslint-disable no-shadow-restricted-names */');
  lines.push('');
  lines.push(
    "import type { Node, NodeTypes, NumericRelation } from './types';",
  );
  lines.push("import { NodeType } from './enums';");
  lines.push("import { SourceLocation } from './types';");
  lines.push("import { getId } from '@math-blocks/core';");
  lines.push('');

  lines.push('const builders = {');

  for (const [name, node] of Object.entries(definitions)) {
    if (name === 'Add' || name === 'Mul' || name === 'Number') {
      continue;
    }

    // eslint-disable-next-line functional/prefer-readonly-type
    const params: [string, string][] = [];
    const binaryArgNames = [];

    if (node.kind === 'operation' || node.kind === 'relation') {
      if (node.argNames) {
        for (const argName of node.argNames) {
          params.push([argName, 'Node']);
        }
      } else {
        switch (node.arity) {
          case 'unary':
            params.push(['arg', 'Node']); // TODO: change to `args: [Node];`
            break;
          case 'binary':
            params.push(['arg0', 'Node']);
            params.push(['arg1', 'Node']);
            binaryArgNames.push('arg0', 'arg1');
            break;
          case 'nary':
            params.push(['args', 'TwoOrMore<Node>']);
            break;
        }
      }
    } else if (node.kind === 'constructor') {
      switch (node.arity) {
        case 'unary':
          params.push(['arg', 'Node']); // TODO: change to `args: [Node];`
          break;
        case 'binary':
          params.push(['args', 'readonly [Node, Node]']);
          break;
        case 'nary':
          if (name === 'Matrix' || name === 'Vector') {
            params.push(['args', 'readonly Node[]']);
          } else {
            params.push(['args', 'TwoOrMore<Node>']);
          }
          break;
      }
    } else if (node.kind === 'number') {
      params.push(['value', 'string']);
    } else if (node.kind === 'identifier') {
      params.push(['name', 'string']);
      params.push(['subscript?', 'Node']);
    } else if (node.kind === 'constant') {
      // no properties
    } else if (node.kind === 'function') {
      params.push(['func', 'Node']);
      params.push(['args', 'readonly Node[]']);
    }

    if ('options' in node && node.options) {
      for (const [key, type] of Object.entries(node.options)) {
        params.push([key, type]);
      }
    }

    params.push(['loc?', 'SourceLocation']);

    lines.push(
      `  ${name.toLowerCase()}: (${params
        .map(([name, type]) => {
          // TODO: find a better way to specify optional params with defaults
          if (
            name === 'implicit' ||
            name === 'subtraction' ||
            name === 'sqrt'
          ) {
            return `${name} = false`;
          } else {
            return `${name}: ${type}`;
          }
        })
        .join(', ')}): NodeTypes['${name}'] => ({`,
    );
    lines.push(`    type: '${node.name}',`);
    lines.push('    id: getId(),');
    if (binaryArgNames.length > 0) {
      lines.push(`    args: [${binaryArgNames.join(', ')}],`);
    }
    for (const param of params) {
      if (param[0].endsWith('?')) {
        lines.push(`    ${param[0].slice(0, -1)},`);
      } else if (!binaryArgNames.includes(param[0])) {
        lines.push(`    ${param[0]},`);
      }
    }
    lines.push('  }),');
  }

  lines.push('');

  lines.push(`  add: (
    terms: readonly Node[],
    loc?: SourceLocation,
  ): Node => {
    switch (terms.length) {
      case 0:
        return builders.number('0'); // , loc);
      case 1:
        return terms[0]; // TODO: figure out if we should give this node a location
      default:
        return {
          type: NodeType.Add,
          id: getId(),
          args: terms as TwoOrMore<Node>,
          loc,
        };
    }
  },`);
  lines.push('');
  lines.push(`  mul: (
    factors: readonly Node[],
    implicit = false,
    loc?: SourceLocation,
  ): Node => {
    switch (factors.length) {
      case 0:
        return builders.number('1'); // , loc);
      case 1:
        return factors[0]; // TODO: figure out if we should give this node a location
      default:
        return {
          type: NodeType.Mul,
          id: getId(),
          implicit,
          args: factors as TwoOrMore<Node>,
          loc,
        };
    }
  },`);
  lines.push('');
  lines.push(`  numRel: (
    args: TwoOrMore<Node>,
    type: NumericRelation['type'],
    loc?: SourceLocation,
  ): NumericRelation => ({
    type,
    id: getId(),
    args,
  }),`);
  lines.push('');
  lines.push(`  number: (
    value: string,
    loc?: SourceLocation,
  ): NodeTypes['Number'] | NodeTypes['Neg'] => {
    if (value.startsWith('-')) {
      // TODO: handle location data correctly
      return builders.neg(builders.number(value.slice(1)));
    }
    return {
      type: NodeType.Number,
      id: getId(),
      value: value.replace(/-/g, '−'),
      loc,
    };
  },`);
  lines.push('');
  lines.push(`  sqrt: (
    radicand: Node,
    loc?: SourceLocation,
  ): NodeTypes['Root'] => builders.root(radicand, builders.number('2'), true, loc),`);

  lines.push('};');
  lines.push('');
  lines.push('export default builders;');
  lines.push('');

  fs.writeFileSync(path.join(__dirname, 'builders.ts'), lines.join('\n'));
};

/* istanbul ignore next */
generateNodeTypes();
/* istanbul ignore next */
// generateNodeUtils();
/* istanbul ignore next */
generateNodeBuilders();
